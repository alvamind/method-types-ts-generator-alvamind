# Project: method-types-ts-generator-alvamind

scripts
src
src/core
src/interfaces
src/utils
test
====================
// .gitignore
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore
# Logs
logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
# Caches
.cache
# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json
# Runtime data
pids
_.pid
_.seed
*.pid.lock
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov
# Coverage directory used by tools like istanbul
coverage
*.lcov
# nyc test coverage
.nyc_output
# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt
# Bower dependency directory (https://bower.io/)
bower_components
# node-waf configuration
.lock-wscript
# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release
# Dependency directories
node_modules/
jspm_packages/
# Snowpack dependency directory (https://snowpack.dev/)
web_modules/
# TypeScript cache
*.tsbuildinfo
# Optional npm cache directory
.npm
# Optional eslint cache
.eslintcache
# Optional stylelint cache
.stylelintcache
# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/
# Optional REPL history
.node_repl_history
# Output of 'npm pack'
*.tgz
# Yarn Integrity file
.yarn-integrity
# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local
# parcel-bundler cache (https://parceljs.org/)
.parcel-cache
# Next.js build output
.next
out
# Nuxt.js build / generate output
.nuxt
dist
# Gatsby files
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public
# vuepress build output
.vuepress/dist
# vuepress v2.x temp and cache directory
.temp
# Docusaurus cache and generated files
.docusaurus
# Serverless directories
.serverless/
# FuseBox cache
.fusebox/
# DynamoDB Local files
.dynamodb/
# TernJS port file
.tern-port
# Stores VSCode versions used for testing VSCode extensions
.vscode-test
# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
# IntelliJ based IDEs
.idea
# Finder (MacOS) folder config
.DS_Store

// .npmignore
# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
# IDE
.idea
.vscode
*.suo
*.njsproj
*.sln
# OS
.DS_Store
Thumbs.db
# Node
node_modules
npm-shrinkwrap.json
# Test
test
# Build
dist
# Git
.git
.gitignore
# Optional
*.tgz

// README.md
# ‚ö°Ô∏è method-types-ts-generator-alvamind ‚ö°Ô∏è
## The Ultimate TypeScript Method Type Generator
[![npm version](https://badge.fury.io/js/method-types-ts-generator-alvamind.svg)](https://badge.fury.io/js/method-types-ts-generator-alvamind)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)
Tired of manually writing TypeScript types for your methods? Say no more! `method-types-ts-generator-alvamind` is here to automate that tedious process, saving you time and headaches. This library scans your TypeScript files, extracts method signatures, and generates a ready-to-use `.d.ts` file with all the types for your exposed methods. Whether you're building microservices, complex applications, or anything in between, this tool will boost your productivity and ensure type safety.
## ‚ú® Features & Benefits
*   **Effortless Type Generation:** Automatically creates TypeScript definitions from your code.
*   **Deep Scanning:** Recursively traverses your directories to find all relevant `.ts` files.
*   **Handles Complex Types:** Supports generics, promises, optional parameters, and more!
*   **Customizable Output:** Control where the generated `.d.ts` file is saved.
*   **Clean & Readable Output:** The generated types are formatted for maximum clarity.
*   **Boosts Productivity:** Eliminate the need to manually maintain method types.
*   **Ensures Type Safety:** Catch potential type errors at compile-time, not runtime.
*   **Easy to Use:** Simple CLI interface makes it a breeze to integrate into your projects.
*   **Framework Agnostic:** Works with any TypeScript project.
*   **Open Source & Free:** Contribute to the project and use it without restrictions.
## üöÄ Getting Started
### Installation
```bash
bun add method-types-ts-generator-alvamind
```
or
```bash
npm install method-types-ts-generator-alvamind
```
### Basic Usage
```bash
method-types-ts-generator-alvamind generate <scanPath> <outputPath>
```
*   `<scanPath>`: The path to the directory containing your TypeScript files.
*   `<outputPath>`: The path to where you want the generated `.d.ts` file.
#### Example
Let's say you have a directory `src/services` with a file like `userService.ts`:
```typescript
interface User {
  id: number;
  name: string;
  email: string;
}
class UserService {
  async getUser(id: number): Promise<User> {
      return { id, name: "John Doe", email: "john@example.com" };
  }
  async createUser(name: string, email:string): Promise<User>{
      return { id: 1, name: name, email: email };
  }
    async updateUser(id:number, user: Partial<User>): Promise<User> {
        return { ...user, id: id} as User
    }
}
```
To generate type definitions, run:
```bash
method-types-ts-generator-alvamind generate ./src/services ./src/generated/exposed-methods.d.ts
```
This will create a file named `exposed-methods.d.ts` in the `src/generated` directory with following content.
```typescript
export interface ExposedMethods {
  UserService: {
    getUser(id: number): Promise<User>;
    createUser(name: string, email: string): Promise<User>;
    updateUser(id: number, user: Partial<User>): Promise<User>;
  };
}
```
Now you can import and use these types in your project!
```typescript
import { ExposedMethods } from './src/generated/exposed-methods';
async function main() {
  const userService = {} as ExposedMethods['UserService']
  const user = await userService.getUser(1);
  console.log(user)
}
main()
```
### Advanced Usage
*   **Nested Directories:** `method-types-ts-generator-alvamind` can scan nested directories to generate types for all your services.
*   **Custom Output Path:** You can specify a custom output path for your generated type definitions.
*  **Generics, Promises, Optionals:** The generator handles all of these types with ease.
## ‚öôÔ∏è How it Works (Under the Hood)
The magic behind `method-types-ts-generator-alvamind` involves several steps:
1.  **Scanning:** It uses the TypeScript compiler API to scan the directory you provide and identifies all `.ts` files.
2.  **Parsing:** It parses each file to find class declarations and methods within those classes.
3.  **Extraction:** It extracts the name and parameter types for each method, including return types.
4.  **Type Generation:** It generates TypeScript interface that represents the structure of the scanned methods.
5. **Output:** Finally it writes the generated type definitions to a `.d.ts` file in the output location.
## üó∫Ô∏è Roadmap
*   **v1.0.0**: Initial release with basic functionality.
*   **v1.1.0**: Support for filtering classes/methods with decorators.
*   **v1.2.0**: Configurable naming patterns for generated interfaces.
*   **v1.3.0**: Support for comments and jsDoc in generated types.
*   **v1.4.0**: Watch mode, automatically regenerate types on file changes.
   * We welcome suggestions and contributions. Please check the "Open Contribution" section below.
## ü§ù Open Contribution
We welcome and encourage contributions to the project! If you have any ideas, bug reports, or feature requests, please submit them as issues. If you would like to contribute to the code, please follow these steps:
1.  Fork the repository.
2.  Create a new branch with your changes.
3.  Submit a pull request with a clear explanation of your changes.
4.  Ensure your code adheres to the projects code style.
## üíñ Support & Donation
`method-types-ts-generator-alvamind` is an open-source project that we dedicate our time to create. If you find it useful, consider supporting us with a donation! Your support enables us to keep the project maintained, add new features, and support the open-source community.
*   **GitHub Sponsors:** [Link to GitHub Sponsors](https://github.com/sponsors/alvamind)
*   **Buy us a coffee:** [Link to donation page](https://www.buymeacoffee.com/alvamind)
## üìú License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
## üìß Contact
If you have any questions or feedback, please feel free to contact us.
*   Email: [alvaminddigital@gmail.com](mailto:alvaminddigital@gmail.com)
*   GitHub: [Alvamind GitHub](https://github.com/alvamind)
Let's build awesome things together! üöÄ

// package.json
{
  "name": "method-types-ts-generator-alvamind",
  "version": "1.0.0",
  "description": "A TypeScript method type generator",
  "type": "module",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/alvamind/method-types-ts-generator-alvamind.git"
  },
  "bin": {
    "method-types-ts-generator": "./dist/scripts/generate-type-cli.js"
  },
  "scripts": {
    "source": "generate-source output=source.md exclude=dist/,README.md,nats-rpc.test.ts,rpc-nats-alvamind-1.0.0.tgz,.gitignore",
    "dev": "bun run src/index.ts --watch",
    "build": "tsc && tsc -p tsconfig.build.json",
    "clean": "rimraf dist",
    "commit": "commit",
    "split-code": "split-code source=combined.ts markers=src/,lib/ outputDir=./output",
    "publish-npm": "publish-npm patch"
  },
  "keywords": [
    "typescript",
    "types",
    "generator",
    "cli"
  ],
  "author": "Alvamind",
  "license": "MIT",
  "files": [
    "dist",
    "src",
    "scripts",
    "README.md",
    "index.d.ts"
  ],
  "dependencies": {
    "alvamind-tools": "^1.0.16",
    "chalk": "4.1.2",
    "ts-morph": "^25.0.0",
    "typescript": "^5.7.2"
  },
  "devDependencies": {
    "@types/bun": "^1.1.14",
    "@types/node": "^20.17.11",
    "bun-types": "^1.1.42",
    "rimraf": "^5.0.10"
  }
}

// scripts/generate-type-cli.ts
#!/usr/bin/env bun
import 'reflect-metadata';
import { generateExposedMethodsType } from '../src/index';
import chalk from 'chalk';
import * as path from "path";
interface CliOptions {
  targetDir: string;
  excludeFiles?: string[];
  outputFile: string;
  returnType?: 'promise' | 'observable' | 'raw';
  logLevel?: 'silent' | 'info' | 'debug';
}
function parseArgs(): CliOptions {
  const args = process.argv.slice(2);
  const options: Partial<CliOptions> = {};
  for (const arg of args) {
    if (arg.startsWith('--')) {
      const [key, value] = arg.slice(2).split('=');
      switch (key) {
        case 'targetDir':
          options.targetDir = value;
          break;
        case 'excludeFiles':
          options.excludeFiles = value.split(',');
          break;
        case 'outputFile':
          options.outputFile = value;
          break;
        case 'returnType':
          if (['promise', 'observable', 'raw'].includes(value)) {
            options.returnType = value as CliOptions['returnType'];
          }
          break;
        case 'logLevel':
          if (['silent', 'info', 'debug'].includes(value)) {
            options.logLevel = value as CliOptions['logLevel'];
          }
          break;
      }
    }
  }
  if (!options.targetDir) {
    console.error(chalk.red('Error: --targetDir is required'));
    process.exit(1);
  }
  if (!options.outputFile) {
    console.error(chalk.red('Error: --outputFile is required'));
    process.exit(1);
  }
  if (!options.returnType) {
    options.returnType = 'raw';
  }
  if (!options.logLevel) {
    options.logLevel = 'silent';
  }
  return options as CliOptions;
}
async function main() {
  if (parseArgs().logLevel !== 'silent') console.log(chalk.blue.bold('\n=== Method Types Generator ==='));
  try {
    const options = parseArgs();
    if (options.logLevel === 'info' || options.logLevel === 'debug') console.log(chalk.cyan('Configuration:'));
    if (options.logLevel === 'info' || options.logLevel === 'debug') console.log(chalk.gray(`Target Directory: ${options.targetDir}`));
    if (options.logLevel === 'info' || options.logLevel === 'debug') console.log(chalk.gray(`Exclude Patterns: ${options.excludeFiles?.join(', ') || 'none'}`));
    if (options.logLevel === 'info' || options.logLevel === 'debug') console.log(chalk.gray(`Output File: ${options.outputFile}`));
    if (options.logLevel === 'info' || options.logLevel === 'debug') console.log(chalk.gray(`Return Type: ${options.returnType}\n`));
    await generateExposedMethodsType(
      {
        scanPath: options.targetDir,
        excludeFiles: options.excludeFiles,
        returnType: options.returnType,
        logLevel: options.logLevel
      },
      options.outputFile,
    );
    if (options.logLevel !== 'silent') console.log(chalk.green.bold(`\n‚úì Successfully generated type definitions`));
    if (options.logLevel !== 'silent') console.log(chalk.gray(`Output: ${path.resolve(options.outputFile)}\n`));
  } catch (error) {
    console.error(chalk.red.bold('\nError generating type definitions:'));
    console.error(chalk.red(error));
    process.exit(1);
  }
}
main();

// src/core/file-scanner.ts
import * as fs from 'fs/promises';
import * as path from 'path';
export async function getAllTsFiles(dir: string, excludePatterns: RegExp[]): Promise<string[]> {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files: string[] = [];
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            files.push(...await getAllTsFiles(fullPath, excludePatterns));
        } else if (entry.isFile() && entry.name.endsWith('.ts')) {
            const shouldExclude = excludePatterns.some(pattern => pattern.test(entry.name));
            if (!shouldExclude) {
                files.push(fullPath);
            }
        }
    }
    return files;
}
export async function scanProject(projectDir: string): Promise<Map<string, string>> {
    const fileMap = new Map<string, string>();
    async function scanDirectory(dir: string) {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                await scanDirectory(fullPath);
            } else if (entry.isFile() && entry.name.endsWith('.ts')) {
                const fileName = path.basename(entry.name, '.ts');
                fileMap.set(fileName, fullPath);
            }
        }
    }
    await scanDirectory(projectDir);
    return fileMap;
}
// src/core/import-resolver.ts
import * as path from 'path';
export function resolveImportPath(outputPath: string, filePath: string, fileMap: Map<string, string>): string {
    const fileName = path.basename(filePath, '.ts');
    const sourceFilePath = fileMap.get(fileName);
    if (!sourceFilePath) {
        throw new Error(`File ${fileName} not found in project.`);
    }
    const relativePath = path.relative(path.dirname(outputPath), path.dirname(sourceFilePath));
    const importPath = path.join(relativePath, fileName).replace(/\\/g, '/');
    return importPath.startsWith('..') ? importPath : `./${importPath}`;
}
// src/core/project-analyzer.ts
import { Project, SourceFile } from 'ts-morph';
import chalk from 'chalk';
import { ClassInfo, MethodInfo } from '../interfaces/class-info.js';
export async function scanClasses(scanPath: string, tsFiles: string[]): Promise<ClassInfo[]> {
    const project = new Project();
    project.addSourceFilesAtPaths(tsFiles);
    const classInfos: ClassInfo[] = [];
    for (const sourceFile of project.getSourceFiles()) {
        sourceFile.getClasses().forEach(classDeclaration => {
            const className = classDeclaration.getName();
            if (!className) return;
            const methods: MethodInfo[] = [];
            classDeclaration.getMethods().forEach(methodDeclaration => {
                const methodName = methodDeclaration.getName();
                methods.push({ methodName });
            });
            classInfos.push({ className, methods });
        });
    }
    return classInfos;
}
// src/core/type-extractor.ts
import {
  Project,
  Type,
  TypeFormatFlags,
  Node,
  Symbol,
  TypeParameterDeclaration,
  MethodDeclaration,
  ParameterDeclaration,
  SourceFile,
  SyntaxKind,
  TypeNode,
  TypeChecker,
  InterfaceDeclaration,
  ClassDeclaration,
  TypeFlags,
} from 'ts-morph';
import { TypeInformation, MethodSignature, MethodParameter, TypeParameter } from '../interfaces/type-information';
import { resolveImportPath } from './import-resolver';
import chalk from 'chalk';
import * as path from 'path';
async function collectImports(
  declaration: Node | undefined,
  imports: Set<string>,
  project: Project,
  outputPath: string,
  scanPath: string,
  fileMap: Map<string, string>
) {
  if (!declaration) return;
  const symbol = declaration.getSymbol();
  if (!symbol) return;
  const typeName = symbol.getName();
  if (["T", "K", "U", "V"].includes(typeName) || ["Promise"].includes(typeName)) {
    return;
  }
  const declarations = symbol.getDeclarations();
  if (!declarations || declarations.length === 0) return;
  const sourceFile = declarations[0].getSourceFile();
  if (!sourceFile) return;
  if (sourceFile.getFilePath().includes("node_modules/typescript/lib")) {
    return;
  }
  const modulePath = sourceFile.getFilePath();
  const fileName = path.basename(modulePath, '.ts');
  const importPath = resolveImportPath(outputPath, modulePath, fileMap);
  if (!Array.from(imports).some(imp => imp.includes(`{ ${typeName} }`))) {
    imports.add(`import { ${typeName} } from '${importPath}';`);
  }
}
function resolveType(type: Type, node: Node, logLevel?: 'silent' | 'info' | 'debug', typeChecker?: TypeChecker, imports?: Set<string>, project?: Project, outputPath?: string, scanPath?: string, fileMap?: Map<string, string>): string {
  if (type.isString()) return "string";
  if (type.isNumber()) return "number";
  if (type.isBoolean()) return "boolean";
  if (type.isNull()) return "null";
  if (type.isUndefined()) return "undefined";
  if (type.isAny()) return "any";
  if (type.isUnknown()) return "unknown";
  if (type.isVoid()) return "void";
  if (type.isLiteral()) return JSON.stringify(type.getLiteralValue());
  if (type.isObject()) {
    const symbol = type.getSymbol();
    if (symbol) {
      if (type.isClass() || type.isInterface()) {
        return symbol.getName();
      }
    }
    if (type.isTuple()) {
      return `[${type.getTupleElements().map(t => resolveType(t, node, logLevel, typeChecker, imports, project, outputPath, scanPath, fileMap)).join(', ')}]`;
    }
    if (type.isAnonymous()) {
      const properties = type.getProperties();
      if (properties.length > 0) {
        const props = properties.map(prop => {
          const declaration = prop.getDeclarations()[0];
          if (declaration && Node.isPropertySignature(declaration)) {
            const name = prop.getName();
            const propType = declaration.getType();
            return `${name}${declaration.hasQuestionToken() ? "?" : ""}: ${resolveType(propType, node, logLevel, typeChecker, imports, project, outputPath, scanPath, fileMap)}`;
          }
          return "";
        }).join(', ');
        return `{${props}}`;
      }
    }
  }
  if (type.isTypeParameter()) {
    const symbol = type.getSymbol();
    if (symbol) return symbol.getName();
    return type.getText();
  }
  if (type.isUnion()) {
    return type.getUnionTypes().map(t => resolveType(t, node, logLevel, typeChecker, imports, project, outputPath, scanPath, fileMap)).join(" | ");
  }
  if (type.isIntersection()) {
    return type.getIntersectionTypes().map(t => resolveType(t, node, logLevel, typeChecker, imports, project, outputPath, scanPath, fileMap)).join(" & ");
  }
  if (type.isEnum()) {
    const symbol = type.getSymbol();
    if (symbol) return symbol.getName();
  }
  if (type.isClassOrInterface()) {
    const symbol = type.getSymbol();
    if (symbol) return symbol.getName();
  }
  if (type.getFlags() & TypeFlags.Object) {
    const symbol = type.getSymbol();
    if (symbol && symbol.getName() === "Promise") {
      const typeArgs = type.getTypeArguments();
      if (typeArgs.length > 0) {
        return `Promise<${typeArgs.map(t => {
          const argType = t;
          if (argType.getSymbol()) {
            collectImports(argType.getSymbol()!.getDeclarations()[0], imports!, project!, outputPath!, scanPath!, fileMap!);
          }
          return resolveType(argType, node, logLevel, typeChecker, imports, project, outputPath, scanPath, fileMap);
        }).join(", ")}>`;
      }
      return `Promise<any>`;
    }
  }
  if (type.getFlags() & TypeFlags.Conditional) {
    return type.getText(node, TypeFormatFlags.NoTruncation);
  }
  if (type.getFlags() & TypeFlags.IndexedAccess) {
    return type.getText(node, TypeFormatFlags.NoTruncation);
  }
  if (logLevel === 'debug') console.log(chalk.yellow(`[DEBUG] Default resolving type: ${type.getText(node, TypeFormatFlags.NoTruncation)}`));
  return type.getText(node, TypeFormatFlags.NoTruncation);
}
function extractTypeParameter(typeParameter: TypeParameterDeclaration, node: Node, logLevel?: 'silent' | 'info' | 'debug', typeChecker?: TypeChecker): TypeParameter {
  return {
    name: typeParameter.getName(),
    constraint: typeParameter.getConstraint() ? resolveType(typeChecker!.getTypeAtLocation(typeParameter.getConstraint()!), node, logLevel, typeChecker) : undefined
  };
}
function extractMethodParameter(parameter: ParameterDeclaration, logLevel?: 'silent' | 'info' | 'debug', typeChecker?: TypeChecker): MethodParameter {
  const paramType = parameter.getType();
  return {
    name: parameter.getName(),
    type: resolveType(paramType, parameter, logLevel, typeChecker),
    optional: parameter.isOptional()
  };
}
function extractMethodSignature(method: MethodDeclaration, logLevel?: 'silent' | 'info' | 'debug', typeChecker?: TypeChecker, imports?: Set<string>, project?: Project, outputPath?: string, scanPath?: string, fileMap?: Map<string, string>): MethodSignature {
  return {
    name: method.getName(),
    typeParameters: method.getTypeParameters().map(param => extractTypeParameter(param, method, logLevel, typeChecker)),
    parameters: method.getParameters().map(parameter => extractMethodParameter(parameter, logLevel, typeChecker)),
    returnType: resolveType(method.getReturnType(), method, logLevel, typeChecker, imports, project, outputPath, scanPath, fileMap)
  };
}
export async function extractTypeInformation(
  scanPath: string,
  tsFiles: string[],
  outputPath: string,
  fileMap: Map<string, string>,
  logLevel?: 'silent' | 'info' | 'debug'
): Promise<TypeInformation> {
  if (logLevel === 'info' || logLevel === 'debug') console.log(chalk.cyan(`[NATS] Extracting type information...`));
  const project = new Project();
  project.addSourceFilesAtPaths(tsFiles);
  const typeChecker = project.getTypeChecker();
  const typeInfo: TypeInformation = {
    imports: new Set<string>(),
    methodSignatures: new Map(),
    localInterfaces: new Set<string>(),
  };
  for (const sourceFile of project.getSourceFiles()) {
    sourceFile.getClasses().forEach(classDeclaration => {
      const className = classDeclaration.getName();
      if (!className) return;
      const methodSignatures = new Map<string, MethodSignature[]>();
      classDeclaration.getMethods().forEach(methodDeclaration => {
        const methodName = methodDeclaration.getName();
        if (logLevel === 'debug') console.log(chalk.magenta(`[DEBUG] Processing method: ${methodName}`));
        const signatures: MethodSignature[] = [];
        const overloads = methodDeclaration.getOverloads();
        if (overloads.length > 0) {
          overloads.forEach(overload => {
            const signature = extractMethodSignature(overload, logLevel, typeChecker, typeInfo.imports, project, outputPath, scanPath, fileMap);
            signatures.push(signature)
            overload.getParameters().forEach(parameter => {
              collectImports(parameter.getType().getSymbol()?.getDeclarations()?.[0], typeInfo.imports, project, outputPath, scanPath, fileMap);
            })
            collectImports(overload.getReturnType().getSymbol()?.getDeclarations()?.[0], typeInfo.imports, project, outputPath, scanPath, fileMap);
          })
        } else {
          const signature = extractMethodSignature(methodDeclaration, logLevel, typeChecker, typeInfo.imports, project, outputPath, scanPath, fileMap)
          signatures.push(signature)
          methodDeclaration.getParameters().forEach(parameter => {
            collectImports(parameter.getType().getSymbol()?.getDeclarations()?.[0], typeInfo.imports, project, outputPath, scanPath, fileMap);
          });
          collectImports(methodDeclaration.getReturnType().getSymbol()?.getDeclarations()?.[0], typeInfo.imports, project, outputPath, scanPath, fileMap);
        }
        methodSignatures.set(methodName, signatures)
      });
      typeInfo.methodSignatures.set(className, methodSignatures)
    });
  }
  if (logLevel === 'info' || logLevel === 'debug') console.log(chalk.cyan(`[NATS] Finished extracting type information`));
  return typeInfo;
}

// src/index.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import chalk from 'chalk';
import { ClassInfo } from './interfaces/class-info';
import { TypeInformation, MethodSignature } from './interfaces/type-information';
import { createRegexPatterns } from './utils/regex-utils';
import { getAllTsFiles, scanProject } from './core/file-scanner';
import { extractTypeInformation } from './core/type-extractor';
import { scanClasses } from './core/project-analyzer';
import { Project } from 'ts-morph';
function generateInterfaceString(classInfos: ClassInfo[], typeInfo: TypeInformation, returnType: string, project: Project): string {
  let output = "// Auto-generated by rpc-nats-alvamind\n\n";
  if (typeInfo.imports.size > 0) {
    output += Array.from(typeInfo.imports).join("\n") + "\n\n";
  }
  output += "export interface ExposedMethods {\n";
  const uniqueClasses = new Map<string, Set<ClassInfo['methods'][number]>>();
  for (const classInfo of classInfos) {
    if (!uniqueClasses.has(classInfo.className)) {
      uniqueClasses.set(classInfo.className, new Set());
    }
    const methods = uniqueClasses.get(classInfo.className)!;
    classInfo.methods.forEach(method => {
      methods.add(method);
    });
  }
  uniqueClasses.forEach((methods, className) => {
    output += `  ${className}: {\n`;
    const methodSignatures = typeInfo.methodSignatures.get(className);
    methodSignatures?.forEach((signatures, methodName) => {
      signatures.forEach(signature => {
        const params = signature.parameters
          .map(p => `${p.name}${p.optional ? "?" : ""}: ${p.type.replace(/import\\([^)]+\\)\\./g, '')}`)
          .join(", ");
        const typeParams = signature.typeParameters.map(p => `${p.name}${p.constraint ? ` extends ${p.constraint}` : ''}`).join(",")
        let returnTypeString = signature.returnType
        returnTypeString = returnTypeString.replace(/import\([^)]+\)\./g, '');
        const isPromiseType = returnTypeString.startsWith('Promise<');
        if (isPromiseType && returnType === 'raw') {
          returnTypeString = returnTypeString.replace(/Promise<(.+)>/, '$1');
        }
        let returnTypeOutput: string;
        switch (returnType) {
          case 'promise':
            returnTypeOutput = isPromiseType ?
              returnTypeString :
              `Promise<${returnTypeString}>`;
            break;
          case 'observable':
            returnTypeOutput = `Observable<${isPromiseType ?
              returnTypeString.replace(/Promise<(.+)>/, '$1') :
              returnTypeString}>`;
            break;
          default: // 'raw'
            returnTypeOutput = returnTypeString;
        }
        output += `    ${signature.name}${typeParams ? `<${typeParams}>` : ""}(${params}): ${returnTypeOutput};\n`;
      })
    })
    output += "  };\n";
  });
  output += "}\n";
  return output;
}
export async function generateExposedMethodsType(
  options: { scanPath: string, excludeFiles?: string[], returnType?: string, logLevel?: 'silent' | 'info' | 'debug' },
  outputPath: string,
) {
  try {
    const excludePatterns = createRegexPatterns(options.excludeFiles);
    const tsFiles = await getAllTsFiles(options.scanPath, excludePatterns);
    console.log(chalk.yellow(`[NATS] Found ${tsFiles.length} TypeScript files to process`));
    const project = new Project();
    project.addSourceFilesAtPaths(tsFiles);
    const fileMap = await scanProject(options.scanPath);
    const { logLevel } = options;
    const typeInfo = await extractTypeInformation(
      options.scanPath,
      tsFiles,
      outputPath,
      fileMap,
      options.logLevel
    );
    const classInfos = await scanClasses(options.scanPath, tsFiles);
    const interfaceString = generateInterfaceString(classInfos, typeInfo, options.returnType || 'raw', project);
    await fs.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.writeFile(outputPath, interfaceString, "utf-8");
  } catch (error) {
    console.error(chalk.red.bold('[NATS] Error generating exposed methods types:'));
    console.error(chalk.red(error));
    throw error;
  }
}

// src/interfaces/class-info.ts
export interface MethodInfo {
    methodName: string;
}
export interface ClassInfo {
    className: string;
    methods: MethodInfo[];
}
// src/interfaces/type-information.ts
import { Type } from 'ts-morph';
export interface TypeParameter {
  name: string;
  constraint?: string;
}
export interface MethodParameter {
  name: string;
  type: string;
  optional: boolean;
}
export interface MethodSignature {
  name: string;
  typeParameters: TypeParameter[];
  parameters: MethodParameter[];
  returnType: string;
}
export interface TypeInformation {
  imports: Set<string>;
  methodSignatures: Map<string, Map<string, MethodSignature[]>>;
  localInterfaces: Set<string>;
}

// src/utils/logger.ts
import chalk from 'chalk';
export type LogLevel = 'silent' | 'info' | 'debug';
export class Logger {
    private static instance: Logger;
    private currentLevel: LogLevel = 'silent';
    private constructor() { }
    static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }
    setLevel(level: LogLevel): void {
        this.currentLevel = level;
    }
    debug(message: string): void {
        if (this.currentLevel === 'debug') {
            console.log(chalk.gray(`[DEBUG] ${message}`));
        }
    }
    info(message: string): void {
        if (this.currentLevel === 'info' || this.currentLevel === 'debug') {
            console.log(message);
        }
    }
    success(message: string): void {
        if (this.currentLevel !== 'silent') {
            console.log(chalk.green(message));
        }
    }
    error(message: string): void {
        console.error(chalk.red(message));
    }
}
export const logger = Logger.getInstance();

// src/utils/regex-utils.ts
export function createRegexPatterns(excludeFiles?: string[]): RegExp[] {
    if (!excludeFiles) return [];
    return excludeFiles.map(pattern => {
        const regexPattern = pattern
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*');
        return new RegExp(regexPattern);
    });
}
// test/main.test.ts
import { describe, test, beforeAll, afterAll, expect, beforeEach, afterEach } from 'bun:test';
import * as fs from 'fs/promises';
import * as path from 'path';
import { generateExposedMethodsType } from '../src';
const testDir = path.join(__dirname, 'test-files');
const outputDir = path.join(__dirname, 'output');
beforeEach(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
  await fs.mkdir(testDir, { recursive: true });
  await fs.writeFile(path.join(testDir, 'temp.ts'), '', 'utf-8');
});
afterAll(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
  await fs.rm(outputDir, { recursive: true, force: true });
});
describe('Type Generator Test Suite', () => {
  beforeEach(async () => {
    await fs.writeFile(path.join(testDir, 'temp.ts'), '', 'utf-8');
  });
  afterEach(async () => {
    await fs.rm(path.join(testDir, 'temp.ts'));
  })
  test('Test Case 1: Basic class with no methods', async () => {
    const input = `
            export class MyClass {}
        `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test1.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain('export interface ExposedMethods');
    expect(output).toContain('MyClass: {');
  });
  test('Test Case 2: Class with single method', async () => {
    const input = `
            export class MyClass {
                myMethod(input: string): string { return input}
            }
        `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test2.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/myMethod\s*\(\s*input:\s*string\s*\):\s*string/);
  });
  test('Test Case 3: Class with method and primitive return type', async () => {
    const input = `
            export class MyClass {
                myMethod(): number { return 1}
            }
        `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test3.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/myMethod\s*\(\s*\):\s*number/);
  });
  test('Test Case 4: Method with Promise return type', async () => {
    const input = `
          export interface MyData<T> {
             data: T;
          }
            export class MyClass {
                async myMethod(input: string): Promise<MyData<string>> { return Promise.resolve({data: input});}
            }
        `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test4.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { MyData } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod\s*\(\s*input:\s*string\s*\).*MyData\s*<\s*string\s*>/);
  });
  test('Test Case 5: Method with generics parameter', async () => {
    const input = `
        export interface MyData<T> {
           data: T;
        }
           export class MyClass {
                myMethod<T>(input: T): MyData<T> { return {data: input}}
            }
        `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test5.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { MyData } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod.*\(\s*input:\s*T\s*\).*MyData\s*<\s*T\s*>/);
  });
  test('Test Case 6: Method with optional parameters', async () => {
    const input = `
           export class MyClass {
               myMethod(input?: string): void {}
           }
       `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test6.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/myMethod\s*\(\s*input\?\s*:\s*string\s*\):\s*void/);
  });
  test('Test Case 7: Method with interface parameter', async () => {
    const input = `
                export interface User {
                    name: string;
                    email: string
                }
                export class MyClass {
                    myMethod(user: User): User { return user}
                }
            `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test7.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { User } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod\s*\(\s*user:\s*.*User\s*\):\s*.*User/);
  });
  test('Test Case 8: Method with Promise return type and promise return type option', async () => {
    const input = `
            export interface MyData<T> {
               data: T;
            }
              export class MyClass {
                   async myMethod(input: string): Promise<MyData<string>> { return Promise.resolve({data: input}) }
              }
          `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test8.d.ts');
    await generateExposedMethodsType({ scanPath: testDir, returnType: 'promise' }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { MyData } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod\s*\(\s*input:\s*string\s*\):\s*Promise\s*<.*MyData\s*<\s*string\s*>.*>/);
  });
  test('Test Case 9: Method with Promise return type and raw return type option', async () => {
    const input = `
        export interface MyData<T> {
           data: T;
        }
          export class MyClass {
               async myMethod(input: string): Promise<MyData<string>> { return Promise.resolve({data: input}) }
           }
        `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test9.d.ts');
    await generateExposedMethodsType({ scanPath: testDir, returnType: 'raw' }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { MyData } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod\s*\(\s*input:\s*string\s*\).*MyData\s*<\s*string\s*>/);
  });
  test('Test Case 10: Class with method that has multi generics parameter and return type', async () => {
    const input = `
           export interface MyData<T> {
                data: T,
           }
           export class MyClass {
                myMethod<T, K>(input: T, option: K): Promise<MyData<{input: T, option: K}>> {
                    return Promise.resolve({data: {input, option}})
                }
           }
       `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test10.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { MyData } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod.*\(\s*input:\s*T,\s*option:\s*K\s*\).*MyData\s*<.*input:\s*T.*option:\s*K.*>/);
  });
  test('Test Case 11: Class with method that has multi generics parameter and raw return type', async () => {
    const input = `
           export interface MyData<T> {
                data: T,
           }
           export class MyClass {
                myMethod<T, K>(input: T, option: K): Promise<MyData<{input: T, option: K}>> {
                    return Promise.resolve({data: {input, option}})
                }
           }
       `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test11.d.ts');
    await generateExposedMethodsType({ scanPath: testDir, returnType: 'raw' }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { MyData } from '../test-files/temp'`);
    expect(output).toMatch(/myMethod.*\(\s*input:\s*T,\s*option:\s*K\s*\).*MyData\s*<.*input:\s*T.*option:\s*K.*>/);
  });
  test('Test Case 12: Multiple classes in different files with shared interfaces', async () => {
    const userService = `
      export interface User {
        id: number;
        name: string;
        email: string;
      }
      export class UserService {
        async getUser(id: number): Promise<User> {
          return { id, name: 'John', email: 'john@example.com' };
        }
        getUsers(): User[] {
          return [{ id: 1, name: 'John', email: 'john@example.com' }];
        }
      }
    `;
    const authService = `
      import { User } from './user.service';
      export class AuthService {
        login(username: string, password: string): Promise<string> {
          return Promise.resolve("token");
        }
        getLoggedInUser(): Promise<User> {
          return Promise.resolve({ id: 1, name: 'John', email: 'john@example.com' });
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'user.service.ts'), userService, 'utf-8');
    await fs.writeFile(path.join(testDir, 'auth.service.ts'), authService, 'utf-8');
    const outputFile = path.join(outputDir, 'test12.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toContain(`import { User } from '../test-files/user.service'`);
    expect(output).toMatch(/UserService:\s*{[^}]*getUser\s*\(\s*id:\s*number\s*\):\s*User/);
    expect(output).toMatch(/getUsers\s*\(\s*\):\s*User\[\]/);
    expect(output).toMatch(/AuthService:\s*{[^}]*login\s*\(\s*username:\s*string,\s*password:\s*string\s*\):\s*string/);
    expect(output).toMatch(/getLoggedInUser\s*\(\s*\):\s*User/);
  });
  test('Test Case 13: Complex service with different return type options', async () => {
    const input = `
      export interface MyData<T> {
        data: T;
        error?: string;
      }
      export class AiService {
        async process(input: string): Promise<MyData<string>> {
          return { data: input };
        }
        processWithOption<T>(input: T): Promise<MyData<T>> {
          return Promise.resolve({ data: input });
        }
        processWithMultiOption<T, K>(input: T, option: K): Promise<MyData<{input: T, option: K}>> {
          return Promise.resolve({ data: { input, option } });
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'ai.service.ts'), input, 'utf-8');
    const outputFileRaw = path.join(outputDir, 'test13-raw.d.ts');
    await generateExposedMethodsType({ scanPath: testDir, returnType: 'raw' }, outputFileRaw);
    const outputRaw = await fs.readFile(outputFileRaw, 'utf-8');
    expect(outputRaw).toMatch(/process\s*\(\s*input:\s*string\s*\):\s*MyData\s*<\s*string\s*>/);
    expect(outputRaw).toMatch(/processWithOption\s*\(\s*input:\s*T\s*\):\s*MyData\s*<\s*T\s*>/);
    const outputFilePromise = path.join(outputDir, 'test13-promise.d.ts');
    await generateExposedMethodsType({ scanPath: testDir, returnType: 'promise' }, outputFilePromise);
    const outputPromise = await fs.readFile(outputFilePromise, 'utf-8');
    expect(outputPromise).toMatch(/process.*:\s*Promise\s*<\s*MyData\s*<\s*string\s*>\s*>/);
    const outputFileObservable = path.join(outputDir, 'test13-observable.d.ts');
    await generateExposedMethodsType({ scanPath: testDir, returnType: 'observable' }, outputFileObservable);
    const outputObservable = await fs.readFile(outputFileObservable, 'utf-8');
    expect(outputObservable).toMatch(/process.*:\s*Observable\s*<\s*MyData\s*<\s*string\s*>\s*>/);
  });
  test('Test Case 14: Handling of Partial and other utility types', async () => {
    const input = `
      export interface User {
        id: number;
        name: string;
        email: string;
      }
      export class UserService {
        async updateUser(id: number, partialUser: Partial<User>): Promise<User> {
          return Promise.resolve({ id: 1, name: 'John', email: 'john@example.com' });
        }
        getFilteredUsers(filter: Pick<User, 'name' | 'email'>): User[] {
          return [{ id: 1, name: 'John', email: 'john@example.com' }];
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'user-update.service.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test14.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/updateUser\s*\(\s*id:\s*number,\s*partialUser:\s*Partial\s*<\s*User\s*>\)/);
    expect(output).toMatch(/getFilteredUsers\s*\(\s*filter:\s*Pick\s*<\s*User,\s*['"]name['"]\s*\|\s*['"]email['"]\s*>\)/);
  });
  test('Test Case 15: Method with default parameters', async () => {
    const input = `
      export class MyClass {
        myMethod(input: string = "default"): string {
          return input;
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test15.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/myMethod\s*\(\s*input\?\s*:\s*string\s*\):\s*string/);
  });
  test('Test Case 16: Overloaded methods', async () => {
    const input = `
      export class MyClass {
        myMethod(input: string): string;
        myMethod(input: number): number;
        myMethod(input: string | number): string | number {
          return input;
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test16.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/myMethod\s*\(\s*input:\s*string\s*\):\s*string/);
    expect(output).toMatch(/myMethod\s*\(\s*input:\s*number\s*\):\s*number/);
  });
  test('Test Case 17: Class inheritance', async () => {
    const input = `
      export class BaseClass {
        baseMethod(): string {
          return "base";
        }
      }
      export class MyClass extends BaseClass {
        myMethod(): string {
          return "child";
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test17.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/baseMethod\s*\(\s*\):\s*string/);
    expect(output).toMatch(/myMethod\s*\(\s*\):\s*string/);
  });
  test('Test Case 18: Complex nested generics', async () => {
    const input = `
      export interface MyData<T> {
        data: T;
      }
      export class MyClass {
        myMethod<T, K>(input: T, option: K): Promise<MyData<{ input: T; option: K; nested: MyData<K> }>> {
          return Promise.resolve({ data: { input, option, nested: { data: option } } });
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test18.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/myMethod\s*<\s*T,\s*K\s*>\s*\(\s*input:\s*T,\s*option:\s*K\s*\):\s*Promise\s*<\s*MyData\s*<\s*\{\s*input:\s*T;\s*option:\s*K;\s*nested:\s*MyData\s*<\s*K\s*>;\s*}\s*>\s*>/);
  });
  test('Test Case 21: Async/Await with complex return type', async () => {
    const input = `
      export interface Response<T> {
        status: number;
        data: T;
      }
      export class ApiService {
        async fetchData<T>(url: string): Promise<Response<T>> {
          const response = await fetch(url);
          return { status: response.status, data: await response.json() };
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test21.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/fetchData\s*<\s*T\s*>\s*\(\s*url:\s*string\s*\):\s*Promise\s*<\s*Response\s*<\s*T\s*>\s*>/);
  });
  test('Test Case 22: Readonly properties and methods', async () => {
    const input = `
      export class ConfigService {
        readonly apiUrl: string = "https://api.example.com";
        getConfig(): { apiUrl: string } {
          return { apiUrl: this.apiUrl };
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test22.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/getConfig\s*\(\s*\):\s*\{\s*apiUrl:\s*string;\s*\}/);
  });
  test('Test Case 23: Conditional types in method signatures', async () => {
    const input = `
      export type IsString<T> = T extends string ? true : false;
      export class TypeChecker {
        checkType<T>(input: T): IsString<T> {
          return (typeof input === "string") as IsString<T>;
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test23.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/checkType\s*<\s*T\s*>\s*\(\s*input:\s*T\s*\):\s*IsString\s*<\s*T\s*>/);
  });
  test('Test Case 24: Mapped types in method signatures', async () => {
    const input = `
      export type ReadonlyRecord<K extends keyof any, T> = {
        readonly [P in K]: T;
      };
      export class RecordService {
        createRecord<K extends string, T>(keys: K[], value: T): ReadonlyRecord<K, T> {
          return keys.reduce((acc, key) => ({ ...acc, [key]: value }), {} as ReadonlyRecord<K, T>);
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test24.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/createRecord\s*<\s*K\s*extends\s*string,\s*T\s*>\s*\(\s*keys:\s*K\[\],\s*value:\s*T\s*\):\s*ReadonlyRecord\s*<\s*K,\s*T\s*>/);
  });
  test('Test Case 25: Recursive types in method signatures', async () => {
    const input = `
      export interface TreeNode<T> {
        value: T;
        children: TreeNode<T>[];
      }
      export class TreeService {
        createTree<T>(value: T, children: TreeNode<T>[] = []): TreeNode<T> {
          return { value, children };
        }
      }
    `;
    await fs.writeFile(path.join(testDir, 'temp.ts'), input, 'utf-8');
    const outputFile = path.join(outputDir, 'test25.d.ts');
    await generateExposedMethodsType({ scanPath: testDir }, outputFile);
    const output = await fs.readFile(outputFile, 'utf-8');
    expect(output).toMatch(/createTree\s*<\s*T\s*>\s*\(\s*value:\s*T,\s*children\?\s*:\s*TreeNode\s*<\s*T\s*>\[\]\s*\):\s*TreeNode\s*<\s*T\s*>/);
  });
});

// tsconfig.build.json
{
  "extends": "./tsconfig.json",
  "exclude": ["test", "dist", "scripts"],
  "compilerOptions": {
    "declaration": true,
    "outDir": "./dist"
  }
}

// tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "commonjs",
    "declaration": true,
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": false,
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "lib": ["ESNext"],
    "types": ["bun-types"]
  },
  "include": ["src*.ts", "scripts*.ts"],
  "exclude": ["node_modules"]
}

